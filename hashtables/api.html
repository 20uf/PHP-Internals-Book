

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HashTables API &mdash; PHP Internals Book</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="PHP Internals Book" href="../index.html" />
    <link rel="up" title="HashTables" href="../hashtables.html" />
    <link rel="next" title="Prerequisites" href="../prerequisites.html" />
    <link rel="prev" title="Basic structure" href="basic_structure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>HashTables API</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="basic_structure.html">Basic structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../prerequisites.html">Prerequisites</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="hashtables-api">
<h1>HashTables API<a class="headerlink" href="#hashtables-api" title="Permalink to this headline">¶</a></h1>
<p>There are two sets of APIs working with hashtables: The first is the lower-level <tt class="docutils literal"><span class="pre">zend_hash</span></tt> API, which will be
discussed in this section. The second one is the array API, which provides some higher-level functions for common
operations and is covered in the next section.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Done</span>
<span class="o">----</span>
<span class="n">zend_hash_init</span>
<span class="n">zend_hash_init_ex</span>
<span class="n">zend_hash_destroy</span>
<span class="n">zend_hash_graceful_destroy</span>
<span class="n">zend_hash_graceful_reverse_destroy</span>
<span class="n">zend_hash_clean</span>
<span class="n">zend_hash_index_update</span>
<span class="n">zend_hash_next_index_insert</span>
<span class="n">zend_hash_index_exists</span>
<span class="n">zend_hash_index_find</span>
<span class="n">zend_hash_index_del</span>
<span class="n">zend_hash_update</span>
<span class="n">zend_hash_exists</span>
<span class="n">zend_hash_find</span>
<span class="n">zend_hash_del</span>
<span class="n">zend_hash_add</span>
<span class="n">zend_hash_quick_update</span>
<span class="n">zend_hash_quick_exists</span>
<span class="n">zend_hash_quick_find</span>
<span class="n">zend_hash_quick_del</span>
<span class="n">zend_hash_quick_add</span>

<span class="n">Todo</span>
<span class="o">----</span>
<span class="n">zend_hash_apply</span>
<span class="n">zend_hash_apply_with_argument</span>
<span class="n">zend_hash_apply_with_arguments</span>
<span class="p">(</span><span class="n">zend_hash_reverse_apply</span><span class="p">)</span>
<span class="n">zend_hash_next_free_element</span>
<span class="n">Iteration</span> <span class="n">API</span>
<span class="n">zend_hash_copy</span>
<span class="n">zend_hash_merge</span>
<span class="n">zend_hash_merge_ex</span>
<span class="n">zend_hash_sort</span>
<span class="n">zend_hash_compare</span>
<span class="n">zend_hash_minmax</span>
<span class="n">zend_hash_num_elements</span>
<span class="n">zend_hash_rehash</span>
<span class="p">(</span><span class="n">zend_hash_func</span><span class="p">)</span>
<span class="n">Symtable</span> <span class="n">API</span>
</pre></div>
</div>
<div class="section" id="creating-and-destroying-hashtables">
<h2>Creating and destroying hashtables<a class="headerlink" href="#creating-and-destroying-hashtables" title="Permalink to this headline">¶</a></h2>
<p>Hashtables are allocated using <tt class="docutils literal"><span class="pre">ALLOC_HASHTABLE</span></tt> and initialized with <tt class="docutils literal"><span class="pre">zend_hash_init</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">myht</span><span class="p">;</span>

<span class="cm">/* Same as myht = emalloc(sizeof(HashTable)); */</span>
<span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>

<span class="n">zend_hash_init</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The second argument to <tt class="docutils literal"><span class="pre">zend_hash_init</span></tt> is a size hint, which specifies how many elements we expect the hashtable to
have. When <tt class="docutils literal"><span class="pre">1000000</span></tt> is passed PHP will allocate space for <tt class="docutils literal"><span class="pre">2^20</span> <span class="pre">=</span> <span class="pre">1048576</span></tt> elements on the first insert. Without
the size hint PHP would first allocate space for 8 elements and then perform multiple resizes once more elements are
inserted (first to 16, then 32, then 64 etc). Every resize requires the <tt class="docutils literal"><span class="pre">arBuckets</span></tt> to be reallocated and a &#8220;rehash&#8221;
to occur (which recomputes the collision lists).</p>
<p>Specifying a size hint avoids those unnecessary resize operations and as such improves performance. This only makes
sense for large hashtables though, for small tables passing 0 should be sufficient. In particular note that 8 is the
minimum table size, so it doesn&#8217;t make a difference if you pass 0 or 2 or 7.</p>
<p>The third argument of <tt class="docutils literal"><span class="pre">zend_hash_init</span></tt> should always be <tt class="docutils literal"><span class="pre">NULL</span></tt>: It was previously used to specify a custom hash
function, but this feature is no longer available. The fourth argument is the destructor function for the stored values
and has the following signature:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dtor_func_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pDest</span><span class="p">);</span>
</pre></div>
</div>
<p>Most of the time this destructor function will be <tt class="docutils literal"><span class="pre">ZVAL_PTR_DTOR</span></tt> (for storing <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> values). This is just the
usual <tt class="docutils literal"><span class="pre">zval_ptr_dtor</span></tt> function but with a signature that is compatible to <tt class="docutils literal"><span class="pre">dtor_func_t</span></tt>.</p>
<p>The last argument of <tt class="docutils literal"><span class="pre">zend_hash_init</span></tt> specifies whether persistent allocation should be used. If you want the
hashtable to live on after the end of the request this argument should be 1. There is a variation of the initialization
function called <tt class="docutils literal"><span class="pre">zend_hash_init_ex</span></tt>, which accepts an additional boolean <tt class="docutils literal"><span class="pre">bApplyProtection</span></tt> argument. By setting it
to 0 you can disable recursion protection (which is otherwise enabled by default). This function is used rather rarely,
usually for internal structures of the engine (like the function or class table).</p>
<p>A hashtable can be destroyed using <tt class="docutils literal"><span class="pre">zend_hash_destroy</span></tt> and freed using <tt class="docutils literal"><span class="pre">FREE_HASHTABLE</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_hash_destroy</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>

<span class="cm">/* Same as efree(myht); */</span>
<span class="n">FREE_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">zend_hash_destroy</span></tt> function will invoke the destructor function on all buckets and free them. While this function
runs the hashtable is in an inconsistent state and can not be used. This is usually okay, but in some rare cases
(especially if the destructor function can call userland code) it may be necessary that the hashtable stays usable
during the destruction process. In this case the <tt class="docutils literal"><span class="pre">zend_hash_graceful_destroy</span></tt> and
<tt class="docutils literal"><span class="pre">zend_hash_graceful_reverse_destroy</span></tt> functions can be used. The former function will destroy the buckets in order of
insertion, the latter in reverse order.</p>
<p>If you want to remove all elements from a hashtable, but not actually destroy it, you can use the <tt class="docutils literal"><span class="pre">zend_hash_clean</span></tt>
function.</p>
</div>
<div class="section" id="integer-keys">
<h2>Integer keys<a class="headerlink" href="#integer-keys" title="Permalink to this headline">¶</a></h2>
<p>Before looking at the functions used to insert, retrieve and delete integer keys in a hashtable, lets first clarify
what kind of arguments they expect:</p>
<p>Remember that the <tt class="docutils literal"><span class="pre">pData</span></tt> member of a bucket stores <em>a pointer</em> to the actual data. E.g. if you store <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt>
values in a hashtable, then <tt class="docutils literal"><span class="pre">pData</span></tt> will be a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt>. That&#8217;s why insertions into a hashtable will require you to
pass a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt> even though you specified <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> as the data type.</p>
<p>When you retrieve values from a hashtable you&#8217;ll pass a destination pointer <tt class="docutils literal"><span class="pre">pDest</span></tt> into which <tt class="docutils literal"><span class="pre">pData</span></tt> will be
written. In order to write into the pointer using <tt class="docutils literal"><span class="pre">*pDest</span> <span class="pre">=</span> <span class="pre">pData</span></tt> yet another level of indirection is needed. So if
<tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> is your datatype you&#8217;ll have to pass a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">***</span></tt> to the retrieval function.</p>
<p>As an example of how this looks like, lets consider the <tt class="docutils literal"><span class="pre">zend_hash_index_update</span></tt> function, which allows you to insert
and update integer keys:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">myht</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">*</span><span class="n">zv</span><span class="p">;</span>

<span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/* In PHP: $array[42] = &quot;foo&quot; */</span>
<span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">zend_hash_destroy</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
<span class="n">FREE_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
</pre></div>
</div>
<p>The above example inserts a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> containing <tt class="docutils literal"><span class="pre">&quot;foo&quot;</span></tt> at key <tt class="docutils literal"><span class="pre">42</span></tt>. The fourth argument specifies the used data
type: <tt class="docutils literal"><span class="pre">sizeof(zval</span> <span class="pre">*)</span></tt>. As such the third argument, which is the inserted value, must be of type <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt>.</p>
<p>The last argument can be used to both insert the value and retrieve it again in the same go:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span>

<span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">);</span>
</pre></div>
</div>
<p>Why would you want to do this? After all, you already know the value you inserted, so why would you want to fetch it
again? Remember that hashtables always work on a <em>copy</em> of the passed value. So, while the <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> stored in the
hashtable will be the same one as <tt class="docutils literal"><span class="pre">zv</span></tt>, it will be stored at a different address. In order to do a by-reference
modification of the hashtable value you need the address of this new location, which is exactly what is written into
<tt class="docutils literal"><span class="pre">zv_dest</span></tt>.</p>
<p>When storing <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> values the last argument of the update function is rarely necessary. On the other hand, when
non-pointer data types are used, you&#8217;ll quite commonly see a pattern where first a temporary structure is created, which
is then inserted into the hashtable and the value in the destination pointer is used for all further work (as changing
the temporary structure would have no effect on the value in the hashtable).</p>
<p>Often you don&#8217;t want to insert a value at a particular key, but append it at the end of the hashtable. This can be
accomplished using the <tt class="docutils literal"><span class="pre">zend_hash_next_index_insert</span></tt> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_next_index_insert</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Z_ADDREF_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function inserts <tt class="docutils literal"><span class="pre">zv</span></tt> at the next available integer key. So if the largest used integer key was <tt class="docutils literal"><span class="pre">42</span></tt> the new
value will be inserted at key <tt class="docutils literal"><span class="pre">43</span></tt>. Note that unlike <tt class="docutils literal"><span class="pre">zend_hash_index_update</span></tt> this function can <em>fail</em> and you need
to check the return value against <tt class="docutils literal"><span class="pre">SUCCESS</span></tt>/<tt class="docutils literal"><span class="pre">FAILURE</span></tt>.</p>
<p>To see when such a failure can occur, consider this example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="n">LONG_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_next_index_insert</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;next_index_insert failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here a value is inserted at key <tt class="docutils literal"><span class="pre">LONG_MAX</span></tt>. In this case the next integer key would be <tt class="docutils literal"><span class="pre">LONG_MAX</span> <span class="pre">+</span> <span class="pre">1</span></tt>, which
overflows to <tt class="docutils literal"><span class="pre">LONG_MIN</span></tt>. As this overflow behavior is undesirable PHP checks for this special case and leaves
<tt class="docutils literal"><span class="pre">nNextFreeElement</span></tt> at <tt class="docutils literal"><span class="pre">LONG_MAX</span></tt>.</p>
<p>When <tt class="docutils literal"><span class="pre">zend_hash_next_index_insert</span></tt> is run it will try to insert the value at key <tt class="docutils literal"><span class="pre">LONG_MAX</span></tt>, but this key is already
taken, thus the function fails.</p>
<p>With the above knowledge the three remaining functions from the integer key API should be fairly straightforward:
<tt class="docutils literal"><span class="pre">zend_hash_index_find</span></tt> gets the value of an index, <tt class="docutils literal"><span class="pre">zend_hash_index_exists</span></tt> checks if an index exists without
fetching the value and <tt class="docutils literal"><span class="pre">zend_hash_index_del</span></tt> removes an entry. Here&#8217;s an example for the three functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_exists</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Index 42 exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Index 42 doesn&#39;t exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Fetched value of index 42 into zv_dest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t fetch value of index 42 as it doesn&#39;t exist :(</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_del</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Removed value at index 42</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t remove value at index 42 as it doesn&#39;t exist :(</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">zend_hash_index_exists</span></tt> return 1 is the index exists, 0 otherwise. The <tt class="docutils literal"><span class="pre">find</span></tt> and <tt class="docutils literal"><span class="pre">del</span></tt> functions return
<tt class="docutils literal"><span class="pre">SUCCESS</span></tt> if the value existed and <tt class="docutils literal"><span class="pre">FAILURE</span></tt> otherwise.</p>
</div>
<div class="section" id="string-keys">
<h2>String keys<a class="headerlink" href="#string-keys" title="Permalink to this headline">¶</a></h2>
<p>String keys are handled very similarly to integer keys. The main difference is that the word <tt class="docutils literal"><span class="pre">index</span></tt> is removed from
all function names. Of course these functions take a string and its length as parameters rather than an index.</p>
<p>The only caveat is what &#8220;string length&#8221; means in this context: In the hashtable API the string length
<strong>includes the terminating NUL byte</strong>. In this regard the <tt class="docutils literal"><span class="pre">zend_hash</span></tt> API differs from nearly all other Zend APIs
which do not include the NUL byte in the string length.</p>
<p>What does this mean practically? When passing a literal string, the string length will be <tt class="docutils literal"><span class="pre">sizeof(&quot;foo&quot;)</span></tt> rather than
<tt class="docutils literal"><span class="pre">sizeof(&quot;foo&quot;)-1</span></tt>. When passing a string from a zval, the string length will be <tt class="docutils literal"><span class="pre">Z_STRVAL_P(zv)+1</span></tt> rather than
<tt class="docutils literal"><span class="pre">Z_STRVAL_P(zv)</span></tt>.</p>
<p>Apart from this the functions are used in exactly the same way as the index functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">myht</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">*</span><span class="n">zv</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>

<span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/* In PHP: $array[&quot;foo&quot;] = &quot;bar&quot; */</span>
<span class="n">zend_hash_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_exists</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Fetched value at key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> into zv_dest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_del</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Removed value at key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zend_hash_exists</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> no longer exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;As key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> no longer exists, zend_hash_find returns FAILURE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">zend_hash_destroy</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
<span class="n">FREE_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span>
</pre></div>
</div>
<p>The above snippet will print:</p>
<div class="highlight-none"><div class="highlight"><pre>Key &quot;foo&quot; exists
Fetched value at key &quot;foo&quot; into zv_dest
Removed value at key &quot;foo&quot;
Key &quot;foo&quot; no longer exists
As key &quot;foo&quot; no longer exists, zend_hash_find returns FAILURE
</pre></div>
</div>
<p>Apart from <tt class="docutils literal"><span class="pre">zend_hash_update</span></tt> another function is offered for inserting string keys: <tt class="docutils literal"><span class="pre">zend_hash_add</span></tt>. The difference
between the two functions is the behavior when the key already exists. <tt class="docutils literal"><span class="pre">zend_hash_update</span></tt> will overwrite the value,
whereas <tt class="docutils literal"><span class="pre">zend_hash_add</span></tt> will return <tt class="docutils literal"><span class="pre">FAILURE</span></tt> instead.</p>
<p>This is how <tt class="docutils literal"><span class="pre">zend_hash_update</span></tt> behaves when you try to overwrite a key:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv1</span><span class="p">,</span> <span class="o">*</span><span class="n">zv2</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>

<span class="cm">/* ... zval init */</span>

<span class="n">zend_hash_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">zv1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">zend_hash_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">zv2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span> <span class="o">==</span> <span class="n">zv1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> contains zv1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span> <span class="o">==</span> <span class="n">zv2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> contains zv2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code will print <tt class="docutils literal"><span class="pre">Key</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">contains</span> <span class="pre">zv2</span></tt>, i.e. the value has been overwritten. Now compare with
<tt class="docutils literal"><span class="pre">zend_hash_add</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv1</span><span class="p">,</span> <span class="o">*</span><span class="n">zv2</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>

<span class="cm">/* ... zval init */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_add</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">zv1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;zend_hash_add returned SUCCESS as key </span><span class="se">\&quot;</span><span class="s">bar</span><span class="se">\&quot;</span><span class="s"> was unused</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_add</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">zv2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv2</span><span class="p">);</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;zend_hash_add returned FAILURE as key </span><span class="se">\&quot;</span><span class="s">bar</span><span class="se">\&quot;</span><span class="s"> is already taken</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span> <span class="o">==</span> <span class="n">zv1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">bar</span><span class="se">\&quot;</span><span class="s"> contains zv1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span> <span class="o">==</span> <span class="n">zv2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key </span><span class="se">\&quot;</span><span class="s">bar</span><span class="se">\&quot;</span><span class="s"> contains zv2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code results in the following output:</p>
<div class="highlight-none"><div class="highlight"><pre>zend_hash_add returned SUCCESS as key &quot;bar&quot; was unused
zend_hash_add returned FAILURE as key &quot;bar&quot; is already taken
Key &quot;bar&quot; contains zv1
</pre></div>
</div>
<p>Here the second call to <tt class="docutils literal"><span class="pre">zend_hash_add</span></tt> returns <tt class="docutils literal"><span class="pre">FAILURE</span></tt> and the value stays at <tt class="docutils literal"><span class="pre">zv1</span></tt>.</p>
<p>Note that while there is a <tt class="docutils literal"><span class="pre">zend_hash_add</span></tt> function for string keys there is no equivalent for integer indices. If
you need this kind of behavior you have to either do an <tt class="docutils literal"><span class="pre">exists</span></tt> call first or make use of a lower-level API:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">_zend_hash_index_update_or_next_insert</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">HASH_ADD</span> <span class="n">ZEND_FILE_LINE_CC</span><span class="p">)</span>
</pre></div>
</div>
<p>For all of the above functions there exists a second <tt class="docutils literal"><span class="pre">quick</span></tt> variant that accepts a precomputed hash value. This
allows you to compute the hash of a string once and then use it across multiple calls. This improves performance as the
hash value does not have to be recomputed every time. The hash value is always passed after the string length:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">ulong</span> <span class="n">h</span><span class="p">;</span> <span class="cm">/* hash value */</span>

<span class="cm">/* ... zval init */</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">zend_get_hash_value</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>

<span class="n">zend_hash_quick_update</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_quick_find</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Fetched value at key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;</span><span class="s"> into zv_dest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_quick_del</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Removed value at key </span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">quick</span></tt> API only makes sense if you are accessing the key a lot (e.g. in a loop). There is no need to make
use of it just because you are accessing the key two or three times. The <tt class="docutils literal"><span class="pre">quick</span></tt> functions are mostly used in the
engine where precomputed hash values are available through various caches and optimizations.</p>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="playing-with-items-inserting-and-removing">
<h2>Playing with items, inserting and removing<a class="headerlink" href="#playing-with-items-inserting-and-removing" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Ok, now let&#8217;s basically play with a hashtable. There are 3 things to remember every time you come to play with hashtables:</dt>
<dd><ul class="first last simple">
<li>Whether the key is an integer or a string, the API call will always differ from both cases</li>
<li>Whether you already got a zval* to insert into the table, or you just would like the table to create it and insert it
for you</li>
<li>If you want to use a string key, whether or not you already computed its hash using the hash function</li>
</ul>
</dd>
</dl>
<p>So, remember this and we are done:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">ht1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht1</span><span class="p">);</span> <span class="cm">/* allocate the table */</span>

<span class="n">zend_hash_init</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Prepare it to accept 3 elements, which you&#39;ll free using ZVAL_PTR_DTOR callback */</span>

<span class="n">zval</span> <span class="o">*</span><span class="n">myval1</span><span class="p">,</span> <span class="o">*</span><span class="n">myval2</span><span class="p">,</span> <span class="o">*</span><span class="n">myval3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">myval1</span><span class="p">);</span><span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">myval2</span><span class="p">);</span><span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">myval3</span><span class="p">);</span> <span class="cm">/* allocate 3 zvals */</span>

<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">myval1</span><span class="p">,</span> <span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* a string */</span>
<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">myval2</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="cm">/* a long */</span>
<span class="n">ZVAL_TRUE</span><span class="p">(</span><span class="n">myval3</span><span class="p">);</span> <span class="cm">/* a boolean */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myval2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* PHP: $array[12] = 42 */</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval myval2 to ht1 at index 12</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_add</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myval1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* PHP: $array[&#39;str&#39;] = &#39;hello world&#39; */</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval myval1 to ht1 at index &#39;str&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ulong</span> <span class="n">key</span><span class="p">;</span>
<span class="cm">/* Next numeric key, Should obviously be 13 here */</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">zend_hash_next_free_element</span><span class="p">(</span><span class="n">ht1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_next_index_insert</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myval3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* PHP: $array[] = true */</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval myval3 to ht1 at index %ld </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be careful of the return type, it&#8217;s not as you would expect 0/1, so, never write something like:
<tt class="docutils literal"><span class="pre">if(zend_hash_add(/*...*/))</span> <span class="pre">{</span></tt> but write: <tt class="docutils literal"><span class="pre">if(zend_hash_add(/*...*/)</span> <span class="pre">==</span> <span class="pre">FAILURE)</span> <span class="pre">{</span></tt>. Always check against
SUCCESS or FAILURE macros     when you use zend_hash API.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You don&#8217;t pass the <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt> to the hashtable, but its address, becoming a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt>.
<em>HashTables always play one level of indirection above what you pass them</em>, so if you pass it, say, an <tt class="docutils literal"><span class="pre">int</span> <span class="pre">**</span></tt>,
it will play with an <tt class="docutils literal"><span class="pre">int</span> <span class="pre">***</span></tt>. We usually use <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt>, so it plays with <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt>.</p>
</div>
<p>As you can see, it&#8217;s a little bit weird to insert zvals into a hashtable. Fortunately, there exists another API witch
goal is to create and allocate the zval for us, just pass its value and you are done. What is special about this API,
is that it doesn&#8217;t play directly with a hashtable itself, but expect you to embed the Hashtable into a zval as well. The
API is so fully zval-turned, but under the hood it uses zend_hash API. Playing with the zval special API, our above
example then become something like that:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">ht1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">ALLOC_INIT_ZVAL</span><span class="p">(</span><span class="n">ht1</span><span class="p">);</span>
<span class="n">array_init</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">add_index_long</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval of type long (42) to ht1 at index 12</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">add_assoc_string</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval of type string (&#39;hello world&#39;) to ht1 at index &#39;str&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* There does not exist something like add_next_index_bool() */</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Like we said, the API is different weither the key you provide is an integer (<tt class="docutils literal"><span class="pre">ulong</span></tt>), or a string
(<tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>) or if you dont provide key at all and let the implementation choose the next one for you. Mainly
&#8220;<em>assoc</em>&#8221; means string keys, and &#8220;<em>index</em>&#8221; means integer keys.</p>
</div>
<p>So, depending on the case, you&#8217;ll choose to use directly the zend_hash API, or go with the zval <tt class="docutils literal"><span class="pre">add_</span></tt> API.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Remember there is no problem having told the zend_hash API we would store 3 elements (using initialisation
function) into it: it will round up our 3 to 4, and, if we would come to add more elements, it automatically
internally resizes itself, we have nothing to do with that when using the API.</p>
</div>
</div>
<div class="section" id="retrieving-deleting-and-checking-for-items">
<h2>Retrieving, deleting and checking for items<a class="headerlink" href="#retrieving-deleting-and-checking-for-items" title="Permalink to this headline">¶</a></h2>
<p>Now we can prepare a hashtable, and feed it with data, mainly zvals. What about looking for our data now? Or checking
whether they exist or not into the table? Let&#8217;s go:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">ht1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht1</span><span class="p">);</span>

<span class="n">zend_hash_init</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">zval</span> <span class="o">*</span><span class="n">myval</span><span class="p">;</span> <span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">myval</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">myval</span><span class="p">,</span> <span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* a string */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* add the value to index 12 */</span>
    <span class="n">zend_error</span><span class="p">(</span><span class="n">E_ERROR</span><span class="p">,</span> <span class="s">&quot;Could not add value to the hashtable&quot;</span><span class="p">);</span>
    <span class="n">zend_bailout</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">zval</span> <span class="o">**</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_find</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">found</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Hey, seems like there is something at numeric key 12, stored it into &#39;found&#39; &quot;</span><span class="p">);</span>
    <span class="n">zend_hash_index_del</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="cm">/* Delete the item */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Same thing as if you look for a value at an integer index, or a string index, you won&#8217;t use the same API call. Also,
remember we added a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt> into the hashtable (the address of a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">*</span></tt>), so, you have to provide the &#8216;find&#8217;
function with a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt>, and as it will have to write to it, you effectively end up passing a <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">***</span></tt> to
&#8216;find&#8217;, as being the address of your <tt class="docutils literal"><span class="pre">zval</span> <span class="pre">**</span></tt> storage.</p>
<p>Should you just want to check for existence?</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_exists</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Yes! */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And if you deal with string type keys, the API becomes:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_exists</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;fookey&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;fookey&quot;</span><span class="p">)))</span> <span class="p">{</span> <span class="cm">/* Returns 1 or 0, no check against macro needed */</span>
    <span class="cm">/* Yes! */</span>
<span class="p">}</span>

<span class="n">zval</span> <span class="o">**</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_find</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;fookey&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;fookey&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">found</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Just to show the call */</span>
    <span class="n">zend_hash_del</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;fookey&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;fookey&quot;</span><span class="p">));</span> <span class="cm">/* Removing the item from the table */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One last thing: if you need to get the current data pointed by the iterator, the API allows you to do so, like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_get_current_data</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">found</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span>  <span class="p">{</span>
    <span class="cm">/* Yes! */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the key, you first have to determine if it&#8217;s a string or an int, then just use the correct argument, like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">keytype</span><span class="p">,</span> <span class="n">num_key</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">str_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">keytype</span> <span class="o">=</span> <span class="n">zend_hash_get_current_key</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">keytype</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">HASH_KEY_NON_EXISTANT</span>:
        <span class="n">zend_error</span><span class="p">(</span><span class="n">E_NOTICE</span><span class="p">,</span> <span class="s">&quot;There is no current element in this array&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">HASH_KEY_IS_INT</span>:
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key was found!, it is an integer: %ld&quot;</span><span class="p">,</span> <span class="n">num_key</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">HASH_KEY_IS_STRING</span>:
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Key was found!, it is a string: &#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">str_key</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="n">EMPTY_SWITCH_DEFAULT_CASE</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/* Just to let you know, we could have called zend_hash_get_current_key_type(ht1, &amp;keytype); as well */</span>
</pre></div>
</div>
</div>
<div class="section" id="string-keys-and-hashing-algorithm">
<h2>String keys and hashing algorithm<a class="headerlink" href="#string-keys-and-hashing-algorithm" title="Permalink to this headline">¶</a></h2>
<p>You know when you use a string key. You know what happens to it when it dives into the zend_hash API call you perform:
it gets hashed by a hashing algorithm. This is a basic concept of hashtables we talked about in introduction chapter.
Let&#8217;s see what the default hashing algo looks like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="n">ulong</span> <span class="nf">zend_inline_hash_func</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arKey</span><span class="p">,</span> <span class="n">uint</span> <span class="n">nKeyLength</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">register</span> <span class="n">ulong</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">5381</span><span class="p">;</span>

        <span class="cm">/* variant with the hash unrolled eight times */</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">nKeyLength</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">nKeyLength</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">nKeyLength</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="mi">7</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">6</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">5</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">4</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">3</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">2</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* fallthrough... */</span>
                <span class="k">case</span> <span class="mi">1</span>: <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">arKey</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">0</span>: <span class="k">break</span><span class="p">;</span>
<span class="n">EMPTY_SWITCH_DEFAULT_CASE</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We won&#8217;t explain it, simply recall what we said in intro: it leads to collisions, in some cases, but it is fast. Faster
enough for common use cases but there is a case where using it would be a pure waste: calling it with several times
the same argument. And this can happen quiet often, imagine you have a string key &#8220;mykey&#8221;, if you happen to call any
zend_hash API with this key, all of them will call for the hash function, and it obviously will always lead to the same
hash result. This is a waste.</p>
<p>That&#8217;s why the zend_hash API is nice about this as it can allow you to call for the hashing function, save the hash
somewhere, and everywhere in the future you could be tempted to use your string key &#8220;mykey&#8221;, you know would be able to
reuse the hash you computed. Save CPU cycles, the idea is as easy as just not asking the CPU for doing several task the
exact same job.</p>
<p>Let&#8217;s show this particular API you could need in your future developments:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">ulong</span> <span class="n">my_hash</span> <span class="o">=</span> <span class="n">zend_get_hash_value</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">));</span>

<span class="n">HashTable</span> <span class="o">*</span><span class="n">ht1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht1</span><span class="p">);</span> <span class="n">zend_hash_init</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">zval</span> <span class="o">*</span><span class="n">myval1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">myval1</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">myval1</span><span class="p">,</span> <span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_quick_add</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="n">my_hash</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">myval1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Added zval myval1 to ht1 at index &#39;str&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_quick_exists</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="n">my_hash</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Just checked, our value is in! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">zend_hash_quick_del</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="n">my_hash</span><span class="p">);</span> <span class="cm">/* Delete the value */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_quick_exists</span><span class="p">(</span><span class="n">ht1</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="n">my_hash</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Obviously, the value is not here any more</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Wondering why, while passing the precomputed hash, we still need to pass the key string at every API call? Well it&#8217;s
easy: because of collisions. There is no fact as &#8220;one string key = exactly one computed hash&#8221;. Collisions can happen,
so the API will obviously use the precomputed hash we provided it, but it will always check for string equality as well
(<tt class="docutils literal"><span class="pre">strcmp</span></tt>), because it never can be sure that at this hash index, there is only our data with our string key. But, we
solved our problem here: we only triggered the hash algorithm once for all, and not for every API call we just
triggered.</p>
</div>
<div class="section" id="iterating-over-the-table">
<h2>Iterating over the table<a class="headerlink" href="#iterating-over-the-table" title="Permalink to this headline">¶</a></h2>
<p>One more need you could meet about hashtables is to iterate over them. The zend_hash API provides all you need about
this, and it also provides ways to apply a callback to elements into hashtables. This is part of the next chapter,
first, let&#8217;s concentrate on how to manually iterate over table items.</p>
<p>Basically, the iteration is just about remembering what the current position is, and this piece of information is stored
in the <tt class="docutils literal"><span class="pre">pInternalPointer</span></tt> field of the hashtable. However, it&#8217;s <em>not recommended</em> to play with this internal position,
because the table you are iterating over may be shared somewhere else, and modifying its internal pointer could lead to
bugs elsewhere, where other functions wouldn&#8217;t expect it to change. This is why the API allows you (and that&#8217;s what
we&#8217;ll always use) to iterate over a hashtable using an external position pointer, welcome the <tt class="docutils literal"><span class="pre">HashPosition</span></tt> type.</p>
<p><tt class="docutils literal"><span class="pre">HashPosition</span></tt> is just a typedef to Bucket *, so it represents the current item, and passing a pointer to this
<tt class="docutils literal"><span class="pre">HashPosition</span></tt> to every iteration-related functions will make them move it: you will iterate without changing the
internal HashTable position which is correct.</p>
<p>Let&#8217;s show an example using all we&#8217;ve learned since the beginning of the chapter:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">HashTable</span> <span class="o">*</span><span class="n">myht</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">myht</span><span class="p">);</span> <span class="n">zend_hash_init</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ZVAL_PTR_DTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">zval</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<span class="n">array</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">IS_ARRAY</span><span class="p">;</span>
<span class="n">array</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">ht</span> <span class="o">=</span> <span class="n">myht</span><span class="p">;</span>

<span class="n">add_assoc_bool</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&quot;bool&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">add_index_double</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">);</span>
<span class="n">add_next_index_string</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&quot;hello world&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">add_assoc_long</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&quot;the answer&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>

<span class="n">HashPosition</span> <span class="n">mypos</span><span class="p">;</span>
<span class="n">zval</span> <span class="o">**</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">ulong</span> <span class="n">longkey</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">strkey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">zend_hash_internal_pointer_reset_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">);</span> <span class="cm">/* Pass mypos */</span>

<span class="k">while</span><span class="p">(</span><span class="n">zend_hash_has_more_elements_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zend_hash_get_current_data_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">);</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;At key &quot;</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">zend_hash_get_current_key_type_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">HASH_KEY_IS_LONG</span>:
            <span class="n">zend_hash_get_current_key_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">strkey</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">longkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">);</span>
            <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld&quot;</span><span class="p">,</span> <span class="n">longkey</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">HASH_KEY_IS_STRING</span>:
            <span class="n">zend_hash_get_current_key_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">strkey</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">longkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">);</span>
            <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;&#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">strkey</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zval</span> <span class="o">*</span><span class="n">datacopy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">copy_and_convert_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">datacopy</span><span class="p">);</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;, we have &#39;%s&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">datacopy</span><span class="p">));</span>
    <span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">datacopy</span><span class="p">);</span>

    <span class="n">zend_hash_move_forward_ex</span><span class="p">(</span><span class="n">myht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mypos</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>

<span class="cm">/* Displays:</span>
<span class="cm">At key &#39;bool&#39;, we have &#39;1&#39;</span>
<span class="cm">At key 1, we have &#39;1.1&#39;</span>
<span class="cm">At key 2, we have &#39;hello world&#39;</span>
<span class="cm">At key &#39;the answer&#39;, we have &#39;42&#39;</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>Notice how we used the &#8216;_ex&#8217; alternative of functions we met before. All functions that deals with &#8220;_current_&#8221; values
or keys should <em>not</em> use the internal iterator pointer anymore like before, but the one we provide ourselves, called
here <tt class="docutils literal"><span class="pre">mypos</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Remember to never modify a hashtable internal pointer. In a real life coding, things are shared, and the
hashtable you&#8217;ll be using will come from someone, to you, and be passed to someone else. Obviously one could expect
the hashtable to now contain more or less items when passing into your hands, noone would expect its internal
iteration pointer to have changed. Always use HashPosition, at least until you really know what you are doing.</p>
</div>
</div>
<div class="section" id="mapping-functions">
<h2>Mapping functions<a class="headerlink" href="#mapping-functions" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="hashalgorithm-and-colliding-the-table">
<h1>HashAlgorithm and colliding the table<a class="headerlink" href="#hashalgorithm-and-colliding-the-table" title="Permalink to this headline">¶</a></h1>
<p>Let&#8217;s recall how all this works: When inserting a data, the (usually) provided key may be of two types: int or string.
If the key is a string, it then passes through the hash algorithm, which is <em>DJBX33A</em> in PHP, and an integer comes out
from this function. If the key were an integer, it is just used as-is. In both cases, we end up having a hash key with
an integer of type <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> (ulong), with no limit in its bounds. So we would need to allocate an array
(<tt class="docutils literal"><span class="pre">arBuckets</span></tt>) that should be referenced from 0 to <tt class="docutils literal"><span class="pre">sizeof(ulong)</span></tt>, something like 18446744073709551615 on 64bits
platform, which is clearly impossible. The problem is that the actual hash key we computed is just too big and has no
bounds on the unsigned long range, it then cannot be used as-is as a C array index because the array would have been too
huge to fit in memory. What is then done as a second step, is that the hash key gets narrow-bounded, using a mask. The
mask cuts of the most significant bits in the integer, and dramatically lowers its space, making it suitable to be
passed as an index for a preallocated C array, <tt class="docutils literal"><span class="pre">arBuckets</span></tt>. The mask is calculated as being the size of the HashTable
minus one. Here is the code for string typed keys:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableMask</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">zend_inline_hash_func</span><span class="p">(</span><span class="n">arKey</span><span class="p">,</span> <span class="n">nKeyLength</span><span class="p">);</span> <span class="cm">/* Hash the arKey (char*) to get the hash key h (ulong) */</span>

<span class="n">nIndex</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableMask</span><span class="p">;</span> <span class="cm">/* Narrow h by masking its highest bits, obtain nIndex, an ulong from 0 to TableSize */</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">arBuckets</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span> <span class="cm">/* Use the nIndex to get back p (Bucket*) from the bucket array arBuckets */</span>
<span class="cm">/* Use p here */</span>
</pre></div>
</div>
<p>We said that if the provided key is of type integer (<tt class="docutils literal"><span class="pre">ulong</span></tt>) and not string (<tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>), we just don&#8217;t need to run
the hash function. Code then becomes:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableMask</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">provided_key</span> <span class="cm">/* of type ulong */</span>

<span class="n">nIndex</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableMask</span><span class="p">;</span> <span class="cm">/* Narrow h by masking its highest bits, obtain nIndex, a ulong from 0 to TableSize */</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">arBuckets</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span> <span class="cm">/* Use the nIndex to get back p (Bucket*) from the bucket array arBuckets */</span>
<span class="cm">/* Use p here */</span>
</pre></div>
</div>
<p>What this means is that if you build a special PHP array, with only integer keys, that when used with the mask give
always the same index, then you will overcollide the array, and end-up having a possibly too huge linked list.
Traversing a linked list is O(n), so the more the linked list grows, the slower it becomes to traverse it. Knowing that the
API has to traverse the lists at every lookup or insertion (which triggers a lookup) in the table, it is then easy to
DOS this part of PHP.</p>
<p>To show this, let&#8217;s build a use case and explain it:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="cm">/* 2^15, for example, any power of 2 works */</span>
<span class="nv">$size</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
<span class="nv">$startTime</span> <span class="o">=</span> <span class="nb">microtime</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nv">$array</span>     <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
<span class="nv">$maxInsert</span> <span class="o">=</span> <span class="nv">$size</span> <span class="o">*</span> <span class="nv">$size</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="nv">$key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$key</span> <span class="o">&lt;=</span> <span class="nv">$maxInsert</span><span class="p">;</span> <span class="nv">$key</span> <span class="o">+=</span> <span class="nv">$size</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$array</span><span class="p">[</span><span class="nv">$key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;%d inserts in %.2f seconds&quot;</span><span class="p">,</span> <span class="nv">$key</span><span class="o">/</span><span class="nv">$size</span><span class="p">,</span> <span class="nb">microtime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="nv">$startTime</span><span class="p">);</span>
</pre></div>
</div>
<p>Running this code, you should obtain something like 32769 insertions in 9.84 seconds, which is just a very huge amount
of time. Let&#8217;s now explain what happens at a lower level. We know that using a key as an integer, no hashing function
comes to play, so the code being run to compute the C array key (<tt class="docutils literal"><span class="pre">nIndex</span></tt>) mainly looks like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">nIndex</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">nTableMask</span><span class="p">;</span> <span class="cm">/* masking */</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">arBuckets</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span>
</pre></div>
</div>
<p>We know that <tt class="docutils literal"><span class="pre">nTableMask</span></tt> is table size minus one. As the key is added 32768 (2 powered by 15) at each step of the for
loop, it jumps from bit to bit, and the mask is just irrelevant:</p>
<div class="highlight-none"><div class="highlight"><pre>for ($key = 0; $key &lt;= $maxInsert; $key += $taille) {
    $array[$key] = 0;
}

mask:   0000.0111.1111.1111.1111
                 &amp;
32768   0000.1000.0000.0000.0000
65536   0001.0000.0000.0000.0000
98304   0001.1000.0000.0000.0000
131072  0010.0000.0000.0000.0000
163840  0010.1000.0000.0000.0000
...
             = 0 !
</pre></div>
</div>
<p>We end up inserting every item (we insert 32769 total items) at the same <tt class="docutils literal"><span class="pre">arBuckets</span></tt> index: 0. Every item is then
added to the linked list sitting at index 0 of <tt class="docutils literal"><span class="pre">arBuckets</span></tt>, and traversing a fast growing linked list takes so much
time. Be convinced by breaking this actual collision-proof code, just use a size of 32767 for example, instead of the
special 32768. You will get something like 32768 inserts in 0.01 seconds, which is about 1000 times faster.</p>
<p>When the hash algorithm + the hash mask works normally, meaning we are not cheating them voluntary like we did, it
distributes pretty well buckets into the <tt class="docutils literal"><span class="pre">arBuckets</span></tt>:</p>
<img alt="../_images/hash_distribution_ok.png" src="../_images/hash_distribution_ok.png" />
<p>When it&#8217;s not the case, you end with something like this, which we could call the &#8216;worst scenario&#8217;:</p>
<img alt="../_images/hash_distribution_ko.png" src="../_images/hash_distribution_ko.png" />
</div>
<div class="section" id="use-cases">
<h1>Use cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h1>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="basic_structure.html">Basic structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../prerequisites.html">Prerequisites</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        Send feedback to <a href="mailto:feedback@phpinternalsbook.com">feedback@phpinternalsbook.com</a>
    </div>
    
    <div class="footer">
        &copy; Copyright 2013, Julien Pauli - Anthony Ferrara - Nikita Popov.
    </div>
    <div class="footer feedback">
        All Rights Reserved
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>